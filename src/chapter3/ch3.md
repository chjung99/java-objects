# Chapter3. 역할, 책임, 협력

## 1. 협력

### 메시지 전송

메시지 전송은 객체 사이의 협력을 위해 사용할 수 있는 유일한 수단이다.

유일하다고 말한 이유는, 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문이다.

예를 들어, Screening 객체와 Movie 객체의 협력을 살펴보자

:Screening --calculateMovieFee(screening)--> :Movie

위에서 Screening이 Movie에게 처리를 위임하는 이유는 요금을 계산하는 데 필요한

기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie이기 때문이다.

### 자율성과 캡슐화

이렇게 하면 Movie 객체의 자율성을 침해하지 않고 적절하게 협력할 수 있다.

만약, 직접 Movie 객체의 내부 값을 사용하여 계산한다면, 이는 Movie 객체의 자율성 훼손으로 이어지고,

해당 객체는 수동적인 존재로 전락하고 만다.

결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화(어떤 걸 노출하고, 어떤 걸 감출지)하는 것이다.

캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.

변경하기 쉬워지는 이유는 Movie 객체 내부 구현에 의존하지 때문에 Movie 객체 내부를 변경해도 Screening까지 전파되지 않기 때문이다.

### 협력이 설계를 위한 문맥을 결정한다

객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 협력이 바뀌면 객체가 제공해야하는 행동 역시 바뀌어야 한다.

협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.

Movie의 행동을 결정하는 것은 영화 예매를 위한 협력이다. 협력이라는 문맥을 고려하지 않고 Movie의 행동을 결정하는 것은

아무런 의미가 없다. 협력이 존재하기 때문에 객체가 존재하는 것이다.

객체의 `행동`을 결정하는 것이 `협력`이라면,

객체의 `상태`를 결정하는 것은 `행동`이다.

객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.

`협력` -> `행동` -> `상태`

결과적으로 객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다.

따라서 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)이다.

## 2. 책임

객체의 책임이란, '무엇을 알고 있는가'와 '무엇을 할 수 있는가'로 구성된다.

- 하는 것(doing)
  - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작 시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것

- 아는 것(knowing)
  - 사적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

### 책임 주도 설계

자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.

따라서 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의해야 한다.

- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

예)

메시지를 선택한다 -> 객체를 선택한다 -> 책임을 할당한다

영화 예매 시스템을 예로 들어 정보 전문가에게 책임을 할당하는 방법을 살펴보자.

시스템이 사용자에게 제공해야 할 기능은 영화를 예매하는 것이고, 이 기능을 책임으로 할당할 것이다.

객체에게 책임을 할당하는 유일한 방법은 메시지를 전송하는 것이므로 책임을 할당다는 것은 메시지의 이름을 결정하는 것과 같다.

```
메시지: 예매하라
객체: Screening

-1: 예매하라 -> :Screening
```

영화를 예매하기 위해선 예매 가격을 계산해야 한다. Screening은 예매 가격을 계산하는 데 필요한 정보를 충분히 알고 있지 않다.
외부 객체에게 가격 계산을 요청이 필요하다. 즉, 새로운 메시지가 필요하다.

```
메시지: 가격을 계산하라
객체: Movie

-1: 예매하라 -> :Screening -2: 가격을 계산하라 -> :Movie
```

가격을 계산하기 위해서는 가격과 할인 정책이 필요하다. 이 모든 정보를 가장 잘 알고 있는 정보 전문가는 Movie다.
가격을 계산할 책임을 Movie에게 할당하자

### 메시지가 객체를 결정한다
객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택했다.

메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있다.

첫째, 객체가 최소한의 인터페이스를 가질 수 있게 된다.

둘째, 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
### 행동이 상태를 결정한다

객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.

초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다. 이런 방식은 객체의 내부 구현이 객체의

퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경이 되고, 

결국 객체에 의존하는 클라이언트로 변경의 영향이 전파된다.

캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.

협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.

중요한 것은 객체의 상태가 아니라 `행동`이다. 협력이 객체의 행동을 결정하고, 행동을 결정하고 나서야 비로소 상태를 결정할 수 있다.

그 행동이 바로 객체의 책임이 된다.

## 3. 역할

역할이란, 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합이다.

협력을 모델링할 때는 특정 객체가 아니라 **역할에게 책임을 할당한다**고 생각하는 게 좋다

예를 들어, 영화 예매 협력에서 예매하라라는 메시지를 처리하기에 적합한 객체로 Screening을 선택했다.

하나의 단계처럼 보이는 이 책임 할당 과정은 실제로는 두 개의 독립적인 단계가 합쳐진 것이다.

첫 번째 단계는 영화를 예매할 수 있는 적절한 역할이 무엇인가를 찾는 것이고,

두번째 단계는 역할을 수행할 객체로 Screening 인스턴스를 선택하는 것이다.

역할에 특별한 이름을 부여하지는 않았지만, 실제로는 익명의 역할을 찾고 그 역할을 수행할 수 있는 객체를 선택하는 방식으로

설계가 진행됐다고 생각하는 것이 자연스럽다.

### 유연하고 재사용 가능한 협력

역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다.

이해를 돕기 위해 역할이라는 개념을 고려하지 않고 객체에게 책임을 바로 할당한다고 가정해보자.

Movie가 가격을 계산하기 위해서는 할인 요금이 필요하기 때문에, 할인 요금을 계산하라라는 메시지를 전송해서 외부의 객체에게 도움을 요청한다.

이때 영화 예매 도메인에는 금액 할인 정책과 비율 할인 정책이라는 두 가지 종류의 가격 할인 정책이 존재하기 때문에

AmountDiscountPolicy 인스턴스와 PercentDiscountPolicy 인스턴스라는 두 가지 종류의 객체가 할인 요금을 계산하라 메시지에 응답할 수 있어야 한다.

그렇다면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 할까?

안타깝게도 이런 방법으로 두 협력을 구현하면 대부분의 코드가 중복되고 말 것이다. 코드 중복은 프로그래밍에서 문제의 근원이기에 피해야한다.

문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야 한다. 순수하게 책임의 관점에서 

두 협력을 바라보면 모두 할인 요금 계산이라는 동일한 책임을 수행한다는 사실을 알 수 있다.

따라서 객체라는 존재를 지우고 할인 요금을 계산하라라는 메시지에 응답할 수 있는 대표자를 생각한다면 두 협력을 하나로 통합할 수 있을 것이다.

이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각할 수 있고, 이 슬롯이 바로 역할이다.

"역할은 다른 것으로 교체할 수 있는 책임의 집합이다"

여기서 역할이 두 종류의 구체적인 객체를 포괄하는 추상화라는 점에 주목하라.

따라서 AmountDiscountPolicy와 PercentDiscountPolicy를 포괄하는 추상적인 이름을 부여해야한다.

역할 이름으로 DiscountPolicy가 어떨까?

요점은 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것이다.

추상화라는 말에서 예상했겠지만 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것이다.

### 객체 대 역할

역할은 객체가 참여할 수 있는 일종의 슬롯이다

협력 -> reference -> 역할 -> select from -> 객체 -> instance of -> 클래스

### 배우와 배역

배우: 객체 <-> 배역: 역할

하나의 배역을 여러 배우가 연기할 수 있는 것처럼 

동일한 역할을 수행하는 하나 이상의 객체들이 존재할 수 있다.

배우가 여러 연극 작품에 참여하면서 여러 배역을 연기할 수 있는 것처럼 

객체 역시 여러 역할을 가질 수 있지만 특정한 협력 안에서는 일시적으로 오직 하나의 역할만 보여진다는 점에 주의하자

따라서 동일한 객체라고 하더라도 객체가 참여하는 협력에 따라 객체의 얼굴안 계속해서 바뀌게 된다.

```text
객체는 다양한 역할을 가질 수 있다. 객체는 협력에 참여할 때 협력 안에서 하나의 역할로 보여진다.
객체가 다른 협력에 참여할 때는 다른 역할로 보여진다.

협력의 관점에서 동일한 역할을 수행하는 객체들은 서로 대체 가능하다.

역할은 특정한 객체의 종류를 캡슐화하기 때문에, 동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적이다
```

# QnA
아, 이제 질문 의도를 확실히 이해했어요. 핵심은 이거죠.

“객체 설계 이전인데, ‘요금 계산 책임은 Movie가 가장 잘 안다’라는 정보를 어떻게 아는가? 아직 객체도 정의되지 않았는데, 정보를 미리 어떻게 알 수 있는가?”

이 부분이 책임주도 설계에서 처음 접하면 헷갈리는 지점이에요. 차근차근 설명드릴게요.

⸻

1. 객체를 설계하기 전에 업무 도메인 이해가 먼저 필요

책임주도 설계(RDD)에서는 객체를 설계하기 전에 도메인 지식을 먼저 파악합니다.
•	예: 영화 예매 시스템에서 “영화 요금 계산”이라는 기능이 필요함을 시스템 요구사항에서 이미 알 수 있음
•	그리고 이 기능을 누가 가장 잘 수행할 수 있는지를 논리적으로 추론합니다.
•	Movie는 영화 기본 요금과 할인 정책 정보를 갖고 있으므로 요금 계산에 ‘정보 전문가’가 될 가능성이 높다.
•	Screening은 상영 시간, 좌석 정보 등만 알고 있으므로 계산 책임을 맡기기 적합하지 않음

즉, 객체가 아니라 도메인 역할(role)이나 정보 전문가 관점에서 판단하는 겁니다.

⸻

2. 역할과 책임은 객체 설계 이전에도 존재할 수 있음
   •	책임과 역할은 객체가 구체적으로 만들어지기 이전에도 논리적으로 정의할 수 있음
   •	예를 들어:

기능 요구사항: 영화 예매 → 요금 계산 필요
정보 전문가 판단: 영화 기본 요금과 할인 정책을 가장 잘 아는 것은 Movie 역할

	•	이 판단을 바탕으로 나중에 객체 설계 단계에서 Movie 객체를 만들고, 책임을 할당하면 됩니다.

⸻

3. 핵심 포인트
    1.	모든 객체가 만들어진 후에 책임을 결정하는 것이 아님
          •	먼저 시스템 요구사항과 도메인을 분석
          •	역할과 책임을 정의 → ‘이 책임을 가장 잘 수행할 역할은 무엇인가?’ 판단
    2.	객체는 역할과 책임을 수행하기 위해 구현되는 단위
          •	따라서 객체 내부 구현까지 알 필요 없음
          •	“책임 수행에 필요한 정보와 행동이 무엇인지” 정도만 추론

⸻

4. 비유로 이해하기
   •	영화 예매 시스템을 회사 조직에 비유하면:
   •	“요금 계산”이라는 업무가 생김 → 누가 맡는 게 좋을까?
   •	회계부서가 가장 적합 → 아직 회계부서 직원(객체)은 만들어지지 않았지만, 역할과 책임은 이미 결정됨
   •	나중에 회계부서 직원을 뽑고(객체 생성) 실제 업무를 맡김

⸻

즉, 객체 설계 이전에는 도메인 분석과 역할 기반 판단을 통해 책임을 배치하고,
객체 설계 단계에서 그 책임을 수행하도록 상태와 행동을 구현하는 흐름입니다.

⸻
